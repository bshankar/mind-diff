#+TITLE: Error detection and correction

Adding some redundant data to check and sometimes facilitate error
correction.

* Types
** Systematic 
   - Original data + fixed number of check bits (parity data)
   - Data ----(a deterministic algorithm)----> check bits
** Non-systematic
  - Original message ---> encoded into a message of length >= original
    message

* Implementation
** Automatic repeat request (ARQ)
   - Backward error correction
   - If block of received data is erroneous, retransmission is
     requested
** Forward error correction (FEC)
   - Sender encodes and sends an error correcting code.
   - Redundant code is used to recover the original data (most likely)
** HARQ
   - Retransmission for major errors, minor errors are corrected

* Error Detection
  - Using hash or checksum
  - Cyclic redundancy check (CRC) can efficiently detect burst errors

  - Burst error
    ...X?????X.... no contiguous subsequence of /m/ correct symbols
    exists within ?????

  - minimum distance coding?   preimage attack?

** Repetition codes
  - Blocks of bits are repeated a few times
  - 1011 1011 1011
  - Very inefficient. Errors at same position cannot be detected

** Parity bit
  - Additional parity bit says whether number of 1s in the message is
    even or odd
  - Can detect odd number of errors

** Checksums
   - \sum C(w_i) % N
   - Parity bits, check digits (Weighted sum of digits % 10 for example) etc

** Cyclic redundancy check
   - Non-secure hash function
   - Parity is a special case of CRC generated by divisor of x + 1
   - [[https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Computation][Computation]]
   - [[https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks][Mathematics]]

** Cryptographic hash functions
   - Protection from maliciously introduced errors
   - Attacker can't hash the modified message

** Hamming code
   - Detects 2 bit errors, can correct 1-bit errors

*** Hamming distance
    - Number of positions where symbols are different in strings of
      equal length
    - for binary strings a, b: H(a, b) = popcount(a XOR b)
